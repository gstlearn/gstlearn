[[naming-convention-for-db-in-gstlearn]]
= Naming Convention for Db in gstlearn

[[preamble]]
== Preamble

[source, javascript]
----
%%javascript
IPython.OutputArea.prototype._should_scroll = function(lines) {
    // Remove Scrollbar in outputs
    return false;
}
----


----<IPython.core.display.Javascript object>----

This tutorial gives answers to the frequently asked question regarding
the Naming Convention used for variables in a Data Base (Db) of gstlearn

[source, ipython3]
----
import numpy as np
import gstlearn as gl
import os
import sys
----

[[prepare-the-environment]]
== Prepare the Environment

This paragraph defines the Space Dimension for the whole notebook. It
also set the name of the Container (and a Prefix) used if Objects are
saved as Neutral Files.

[source, ipython3]
----
ndim = 2
gl.ASpaceObject.defineDefaultSpace(gl.SPACE_RN,ndim)

gl.ASerializable.setContainerName(True)
gl.ASerializable.setPrefixName("DbTest-");
----

The following object will enable having a complete view of the column /
attribute manipulation. It will be used later in the notebook.

[source, ipython3]
----
dbfmt = gl.DbStringFormat()
dbfmt.setParams(gl.FLAG_LOCATOR)
----

[[creating-a-data-file]]
== Creating a data file

A Data Base is created for experimentation. It is constructed as a
regular Grid (named *grid*). The variable _nech_ will contain the number
of samples within _grid_. The number of meshes is voluntarily limited.
The mesh is square with dimension 1. The origin (lower left corner) is
set to (10,20) in order to be able to distinguish coordinates along
first and second axes.

[source, ipython3]
----
grid = gl.DbGrid.create([5,5], [1,1], [10,20])
nech = grid.getSampleNumber()
print("Number of sample =",nech)
grid
----


----
Number of sample = 25

Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 3
Maximum Number of UIDs       = 3
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x1 - Locator = x1
Column = 2 - Name = x2 - Locator = x2----

The data base contains 3 fields, created automatically and respectively
called _rank_, _x1_ and _x2_. Note that the last two fields are
considered as coordinates (locator _x_).

[[naming-convention]]
== Naming convention

We now add one new field (named _first_) where values are generated
randomly (uniform drawn between 0 and 1). Note that, when adding this
new field, a value is returned which corresponds to the number of the
newly created _attribute_.

*Important remark: all numerical variables used to identify a field
within a Db are considered as indices, i.e. they are numbered starting
from 0*

[source, ipython3]
----
tab = gl.ut_vector_simulate_uniform(nech)
iatt1 = grid.addColumns(tab,"first")
print("Attribute corresponding to 'first' =",iatt1)
----


----
Attribute corresponding to 'first' = 3
----

We can double-check the attribute information by visiting the current
contents of the _grid_ Db. We check that the field _first_ is the fourth
(i.e. attribute #3).

[source, ipython3]
----
grid
----


----
Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 4
Maximum Number of UIDs       = 4
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x1 - Locator = x1
Column = 2 - Name = x2 - Locator = x2
Column = 3 - Name = first - Locator = NA----

Let us add a series (3) of fields created simulateneously. They are
filled with a constant value equal to 5. We also define a locator
assigned to all the newly created variables: they will be considered as
data variable (locator = _z_). Note the returned value: it corresponds
to the attribute number assigned to the first new variable.

[source, ipython3]
----
iatt2 = grid.addColumnsByConstant(3,5.,"second",gl.ELoc.Z)
print("Attribute corresponding to the first variable named 'second-x' =",iatt2)
grid
----


----
Attribute corresponding to the first variable named 'second-x' = 4

Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 7
Maximum Number of UIDs       = 7
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x1 - Locator = x1
Column = 2 - Name = x2 - Locator = x2
Column = 3 - Name = first - Locator = NA
Column = 4 - Name = second-1 - Locator = z1
Column = 5 - Name = second-2 - Locator = z2
Column = 6 - Name = second-3 - Locator = z3----

Note that the newly created fields are automatically named using the
provided string (_second_) as a radix: the variables are names
*second-1", "second-2" and "second-3".

Let us now envisage renaming the variable _second-2_ into _first_.

[source, ipython3]
----
grid.setName("second-2","first")
grid
----


----
Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 7
Maximum Number of UIDs       = 7
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x1 - Locator = x1
Column = 2 - Name = x2 - Locator = x2
Column = 3 - Name = first - Locator = NA
Column = 4 - Name = second-1 - Locator = z1
Column = 5 - Name = first.1 - Locator = z2
Column = 6 - Name = second-3 - Locator = z3----

As the name _first_ already exists, the field has been renamed to
_first.1_ instead.

We now wish to rename the field _second-3_ into _first_.

[source, ipython3]
----
grid.setName("second-3","first")
grid
----


----
Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 7
Maximum Number of UIDs       = 7
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x1 - Locator = x1
Column = 2 - Name = x2 - Locator = x2
Column = 3 - Name = first - Locator = NA
Column = 4 - Name = second-1 - Locator = z1
Column = 5 - Name = first.1 - Locator = z2
Column = 6 - Name = first.1.1 - Locator = z3----

The automatic renaming procedure has been applied (adding ".1")
iteratively until names are all different: the field is now called
*first.1.1".

Now that we have demonstrated the uniqueness of the names, are there are
ways to designate a field? For the next demonstrations, we first recall
the current status of the current Db.

In order to make the next paragrah more demonstrative, we change the
contents of several fields

[source, ipython3]
----
grid.setColumn(gl.ut_vector_simulate_uniform(nech),"second-1")
grid.setColumn(gl.ut_vector_simulate_uniform(nech),"first.1")
grid.setColumn(gl.ut_vector_simulate_uniform(nech),"first.1.1")
----

[source, ipython3]
----
grid
----


----
Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 7
Maximum Number of UIDs       = 7
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x1 - Locator = x1
Column = 2 - Name = x2 - Locator = x2
Column = 3 - Name = first - Locator = NA
Column = 4 - Name = second-1 - Locator = z1
Column = 5 - Name = first.1 - Locator = z2
Column = 6 - Name = first.1.1 - Locator = z3----

[[by-name]]
=== By Name

As an example, we access to the field named *first.1. For short, only
the four first values are systematically printed.

[source, ipython3]
----
grid.getColumn("first.1")[0:4]
----


----(0.48907791183060095,
 0.3531807422130994,
 0.08397793237543762,
 0.8176828994209496)----

[[by-column-index]]
=== By Column Index
We recall that the index numbering starts from 0. Therefore field *first-1*  corresponds to the index 5.
[source, ipython3]
----
grid.getColumnByColIdx(5)[0:4]
----


----(0.48907791183060095,
 0.3531807422130994,
 0.08397793237543762,
 0.8176828994209496)----

[[by-attribute-index]]
=== By Attribute Index

[source, ipython3]
----
grid.getColumnByUID(5)[0:4]
----


----(0.48907791183060095,
 0.3531807422130994,
 0.08397793237543762,
 0.8176828994209496)----

[[by-locator]]
=== By Locator

We note that the target variable corresponds to the locator _z2_ which
is the second one (index 1) or the Z-locator type.

[source, ipython3]
----
grid.getColumnByLocator(gl.ELoc.Z,1)[0:4]
----


----(0.48907791183060095,
 0.3531807422130994,
 0.08397793237543762,
 0.8176828994209496)----

[[difference-between-column-and-attribute]]
== Difference between Column and Attribute

We need to recall the _attribute_ value returned when adding the fields:
- _iatt1_ (3) when adding the field named _first_ - _iatt2_ (4) when
adding the series of 3 fields (originally named after the radix
_second_)

To better understand, we need to ask for the display of the data base
with a specific option which describes the current status of the
attributes, either unsorted or through an order driven by the locator

[source, ipython3]
----
grid.display(dbfmt)
----


----

Data Base Grid Characteristics
==============================

List of unsorted UIDs
---------------------
Maximum number of positions = 7
Number of Columns           = 7
UID = 0 1 2 3 4 5 6 


List of locators
----------------
1 - Locator: x
- Attributes = 1 2 
- Columns    = 1 2 
2 - Locator: z
- Attributes = 4 5 6 
- Columns    = 4 5 6 

 ----

We can see that the 7 existing fields currently correspond to the 7
first columns of the Data Base _grid_. The second display gives the
indices of the locators in use (_x_ and _z_) and the indeices of the
attributes corresponding to the ranks of the items for each locator
type.

Things become more interesting if a field is deleted. To avoid any
ambiguity, the field is designated by its name (say _x1_)

[source, ipython3]
----
grid
----


----
Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 7
Maximum Number of UIDs       = 7
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x1 - Locator = x1
Column = 2 - Name = x2 - Locator = x2
Column = 3 - Name = first - Locator = NA
Column = 4 - Name = second-1 - Locator = z1
Column = 5 - Name = first.1 - Locator = z2
Column = 6 - Name = first.1.1 - Locator = z3----

[source, ipython3]
----
grid.deleteColumn("x1")
grid
----


----
Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 6
Maximum Number of UIDs       = 7
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x2 - Locator = x1
Column = 2 - Name = first - Locator = NA
Column = 3 - Name = second-1 - Locator = z1
Column = 4 - Name = first.1 - Locator = z2
Column = 5 - Name = first.1.1 - Locator = z3----

The previous printout shows the current contents of the data base where
the field _x1_ has been suppressed. Note an important feature of the
_locator_ notion. For a given locator type (say _x_ for coordinates),
the locator type is unique and sorted continuously starting from 1.
Therefore, when we suppressed the variable _x1_ (which corresponded to
the locator type _x_ and locator rank _1_), the variable _x2_ is
modified: its name and locator type are not changed but the locator rank
is update from _2_ to _1_.

We now look at the attributes internal management

[source, ipython3]
----
grid.display(dbfmt)
----


----

Data Base Grid Characteristics
==============================

List of unsorted UIDs
---------------------
Maximum number of positions = 7
Number of Columns           = 6
UID = 0 -1 1 2 3 4 5 


List of locators
----------------
1 - Locator: x
- Attributes = 2 
- Columns    = 1 
2 - Locator: z
- Attributes = 4 5 6 
- Columns    = 3 4 5 

 ----

We can see that the list of attributes has not been reduced: the maximum
number of positions is still equal to 7. Instead, the rank of the
attribute which corresponded to _x1_ is now set to -1, to signify that
the column is actually missing. The display sorted by locator does not
need any additional explanation.

Let us now retrieve the information of variable _first.1_ as we did
before. We start by addressing the variable by name.

[source, ipython3]
----
grid.getColumn("first.1")[0:4]
----


----(0.48907791183060095,
 0.3531807422130994,
 0.08397793237543762,
 0.8176828994209496)----

We can similarly address it by its column index (the column has moved to
rank 5)

[source, ipython3]
----
grid.getColumnByColIdx(4)[0:4]
----


----(0.48907791183060095,
 0.3531807422130994,
 0.08397793237543762,
 0.8176828994209496)----

The magic of the _attribute_ notion is that it can still be used
*unchanged*

[source, ipython3]
----
grid.getColumnByUID(5)[0:4]
----


----(0.48907791183060095,
 0.3531807422130994,
 0.08397793237543762,
 0.8176828994209496)----

Obviously, trying to read the field which corresponds to the field _x1_
(that has just been deleted) returns an empty vector.

[source, ipython3]
----
grid.getColumnByUID(1)
----


----()----

[[remark-on-space-dimension]]
== Remark on Space Dimension

It might be considered as surprising to see that _grid_ is considered as
a 2-D Grid while there is only *one* coordinate field (locator _x_). In
order to avoid any missunderstanding, let us recall this important fact.

The data base _grid_ is organized as a grid and for that sake, it
contains a descrption of the grid organization. This organization is
used to elaborate the coordinates (for example when calling
_getCoordinate()_ method). The coordinate vectors must only be
considered as decoration: they will not be used in any internal
operation.

As an example this makes particular sense here as the contents of the
variable _x2_, despite its locator rank _1_ (i.e. index 0) actually
contains the *second* coordinate of the samples, as demonstrated in the
next line

[source, ipython3]
----
grid.getColumnByLocator(gl.ELoc.X, 0)
----


----(20.0,
 20.0,
 20.0,
 20.0,
 20.0,
 21.0,
 21.0,
 21.0,
 21.0,
 21.0,
 22.0,
 22.0,
 22.0,
 22.0,
 22.0,
 23.0,
 23.0,
 23.0,
 23.0,
 23.0,
 24.0,
 24.0,
 24.0,
 24.0,
 24.0)----

Note that at any time, the coordinate vectors can be regenerated. To
avoid confusion, the newly generated coordinate fields are named using
the radix "X" (uppercase). This feature is obviously only available in
the case of a grid

[source, ipython3]
----
grid.generateCoordinates("X")
----


----

Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 8
Maximum Number of UIDs       = 9
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x2 - Locator = NA
Column = 2 - Name = first - Locator = NA
Column = 3 - Name = second-1 - Locator = z1
Column = 4 - Name = first.1 - Locator = z2
Column = 5 - Name = first.1.1 - Locator = z3
Column = 6 - Name = X-1 - Locator = x1
Column = 7 - Name = X-2 - Locator = x2
 ----

[source, ipython3]
----
grid.getColumnByLocator(gl.ELoc.X, 0)
----


----(10.0,
 11.0,
 12.0,
 13.0,
 14.0,
 10.0,
 11.0,
 12.0,
 13.0,
 14.0,
 10.0,
 11.0,
 12.0,
 13.0,
 14.0,
 10.0,
 11.0,
 12.0,
 13.0,
 14.0,
 10.0,
 11.0,
 12.0,
 13.0,
 14.0)----

Similarly, we can generate a field containing the sample rank (similar
as the information contained in the Field #1). Here again, we generate a
new field containing this rank information: in order to avoid confusion,
the new variable is called _RANK_ (uppercase). Note that this field does
not have any locator attached.

[source, ipython3]
----
grid.generateRank("RANK")
grid
----


----
Data Base Grid Characteristics
==============================

Data Base Summary
-----------------
File is organized as a regular grid
Space dimension              = 2
Number of Columns            = 9
Maximum Number of UIDs       = 10
Total number of samples      = 25

Grid characteristics:
---------------------
Origin :     10.000    20.000
Mesh   :      1.000     1.000
Number :          5         5

Variables
---------
Column = 0 - Name = rank - Locator = NA
Column = 1 - Name = x2 - Locator = NA
Column = 2 - Name = first - Locator = NA
Column = 3 - Name = second-1 - Locator = z1
Column = 4 - Name = first.1 - Locator = z2
Column = 5 - Name = first.1.1 - Locator = z3
Column = 6 - Name = X-1 - Locator = x1
Column = 7 - Name = X-2 - Locator = x2
Column = 8 - Name = RANK - Locator = NA----

[[conclusion]]
== Conclusion

As a conclusion:

* the variables can be used *safely* when designating them by their
*name*
* the variables can be used easily when addressing them using the
locator notion (type and index)
* the use of (column) index is always valid. This index must be defined
precisely when using the variable (it must be updated in case of
addition or deletion of other variables)
* the use of attribute is clever... but it must be used by expert who
understands the process. It allows using fix values, independently of
the management of other fields

We also recall that all numbering refer to indices (0 based numbering).
This is the case for _(column) index_ as well as _locator index_ per
locator type.
