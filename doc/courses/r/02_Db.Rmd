---
title: "Tutorial on Data Base"
author: "gstlearn Team"
output:
  html_document:
    df_print: paged
    toc: true
  pdf_document:
    toc: true
---

```{r, include=FALSE}
## Global options for code chunks
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  fig.width=3.5,fig.height=2.5,fig.align="center"
)
```

# Preamble

In this preamble, we load the **gstlearn** library.

```{r Preamble, message=FALSE}
rm(list=ls())
library(gstlearn)
library(ggplot2)
library(ggpubr)
```

------------------------------------------------------------------------

# Main Classes

Here is a (non-exhaustive) list of classes of objects in **gstlearn**:

-   Db, DbGrid: Numerical data base
-   DirParam, VarioParam and Vario: Experimental variograms
-   Model: Variogram model
-   Neigh: Neighborhood
-   Anam: Gaussian anamorphosis
-   Polygon: 2-D polygonal shapes
-   Rule: Lithotype rule for thresholds used for truncated plurigaussian models

------------------------------------------------------------------------

# Loading a CSV File

We start by downloading the file called `Scotland_Temperatures.csv` and we store it in the current working directory. In this example, the file (called `filecsv`) is provided as a *CSV* format file. We load it into a data frame (named `datcsv`) using the relevant R-command.

```{r}
dlfile = "https://soft.minesparis.psl.eu/gstlearn/data/Scotland/Scotland_Temperatures.csv"
filecsv = "Scotland_Temperatures.csv"
download.file(dlfile, filecsv)
datcsv = read.csv(filecsv)
```

We can check the contents of the data frame (by simply typing its name) and see that it contains four columns (respectively called `Longitude`, `Latitude`, `Elevation`, `January_temp`) and 236 rows (header line excluded).

```{r}
datcsv
```

Note that the last column contains several values called *MISS*: this corresponds to the absence of information.


------------------------------------------------------------------------


# Creating Db object

We now want to load this information in order to obtain a data base of the **gstlearn** package (or *Db*) that will be called `dat`. This operation can be performed directly by reading the CSV file again and load it directly into a Db.

To do so, we start by creating `CSVformat` object using the `CSVformat_create` function. This object is used to specify various properties of the file we want to load, namely the presence of a header (through the argument `flagHeader`) and the way missing values are coded in the file (through the argument `naString`).

Then, the function `Db_createFromCSV` allows to load directly the CSV file into a **gstlearn** data base.

```{r}
csv = CSVformat_create(flagHeader=TRUE, naString = "MISS")
dat = Db_createFromCSV(filecsv, csv=csv)
dat
```

------------------------------------------------------------------------

# Importing Db File

A last solution is to import it directly from the set of demonstration files (provided together with the package and called `fileNF`) and stored in a specific format (Neutral file).

These *NF* (or neutral file) are currently used for serialization of the gstlearn objects. They will probably be replaced in the future by a facility backuping the whole workspace in one step.

Note that the contents of the Db is slightly different from the result obtained when reading from CSV. Essentially, some variables have a `Locator` field defined, some do not. This concept will be described later in this chapter and the difference can be ignored.

```{r}
dlfile = "https://soft.minesparis.psl.eu/gstlearn/data/Scotland/Scotland_Temperatures.NF"
fileNF = "Scotland_Temperatures.NF"
download.file(dlfile, fileNF)
dat = Db_createFromNF(fileNF)
dat
```

------------------------------------------------------------------------

# Db class

*Db* objects have a method `display` allowing to print a summary of the content of the data base.

```{r}
dat$display()
```
Equivalently, we can simply type the name of the *Db* object in a console to get the summary of its content.

```{r}
dat
```
As described in the "Data Base Summary" section, this *Db* object contains 5 fields (called *Columns*), and  contains 236 data points (called *samples*). Upon inspection, we see that the 4 variables of the csv file are present (Columns 1 through 4), alongside with an additional variable called `rank` (Column 0). The `rank` variable is a variable present by default in all *Db* objects, and contains the index (starting at 1) of each sample/data point in the data base.

Remark: To get more information on the contents of the Db, we can provide the `display` method of a *Db* with a *DbStringFormat* object used to describe which information we would like to print. Such objects can be created using the function `DbStringFormat_createFromFlags`. We refer the reader to the documentation of the *DbStringFormat* class for more details. The example below provides a way to add summary statistics about some variables of the *Db* to the *Db* summary.


```{r}
dbfmt = DbStringFormat_createFromFlags(flag_stats=TRUE, names=c("Elevation", "January_temp"))
dat$display(dbfmt)
```

------------------------------------------------------------------------

# Assessors for Db class

We can also consider the data base as a data frame and use the `[ ]` assessors. For instance, the full content of a `Db` can be displayed as a data frame as follows. 

```{r}
dat[]
```

We can access one or several variables using their names. 

```{r}
dat["January_temp"]
```
Note that the contents of the Column corresponding to the target variable (i.e. `January_temp`) is produced as a series of values (printed along a line). Also note the presence of samples with `NA` corresponding to those where the target variable is not informed.


But we can be more restrictive as in the next example, where we consider the samples 10 to 15 of the variables `Latitude` and `Elevation`.

```{r}
dat[10:15, c("Latitude", "Elevation")]
```


We can also replace the variable name by their *Column* index in the data base. 

```{r}
dat[10:15, 3:4]
```

This is not recommended as the Column index of a given variable may vary over time.

Finally, an interesting feature of the `[ ]` assessors is that it allows to easily incorporate new variables into a *Db* or modify the existing ones. For instance, in the next example, a new variable `newvar` is created and added to the data base `dat`.

```{r}
dat["newvar"] = 12.3 * dat["Elevation"] - 2.1 * dat["*temp"]
dat
```

Remark: Note that variables names may be specified using traditional regexp expressions (for instance, the symbol '\*' replaces any list of characters meaning that `["*temp"]` selects all the variable names ending with `temp`).

------------------------------------------------------------------------

# Locators

The locators are used to specify the **role** assigned to a Column for the rest of the study (unless they are modified). The locator is characterized by its name (`Z` for a variable and `X` for a coordinate) within the Enumeration `ELoc` and its rank.


```{r}
# --- MP ---
ELoc_printAll()
```

```{r}
dat$setLocators(c("Longitude","Latitude"), ELoc_X())
dat$setLocator("*temp", ELoc_Z(), cleanSameLocator=TRUE)
dat
```

As can be seen in the printout, variables `Latitude` and `Longitude` have been designated as coordinates (pay attention to the order) and `January_temp` is the (unique) variable. Therefore any subsequent step will be performed as a monovariate 2-D process.

The locator is translated into a *letter*,*number* pair for better legibility: e.g. `x1` for the first coordinate.

------------------------------------------------------------------------

# Plotting a Db

Plot the contents of a Db using functions of the **plot.R** package. The proportional option is used to represent to `january_temp` variable

```{r}
p = ggDefaultGeographic()
p = p + plot.point(dat, name_size="January_temp", show.legend.symbol = TRUE,
                   legend.name.size="Temperature")
p = p + plot.decoration(title="My Data Base", xlab="Easting", ylab="Northing")
ggPrint(p)
```



A more elaborated graphic representation displays the samples with a symbol proportional to the Elevation and a color representing the Temperature.

```{r}
p = ggDefaultGeographic()
p = p + plot.point(dat, name_size="Elevation", name_color="January_temp")
p = p + plot.decoration(title="My Data Base", xlab="Easting", ylab="Northing")
ggPrint(p)
```

------------------------------------------------------------------------

# Grid Data Base

On the same area, a terrain model is available (as a demonstration file available in the package distribution). We first download it as an element of a data base defined on a grid support (*DbGrid*).

```{r}
dlfile = "https://soft.minesparis.psl.eu/gstlearn/data/Scotland/Scotland_Elevations.NF"
fileNF = "Scotland_Elevations.NF"
download.file(dlfile, fileNF)
grid = DbGrid_createFromNF(fileNF)
grid
```

We can check that the grid is constituted of 81 columns and 137 rows, or 11097 grid cells.

------------------------------------------------------------------------

# Selection

We can check the presence of a variable (called `inshore`) which is assigned to the `sel` locator: this corresponds to a *Selection* which acts as a binary filter: some grid cells are active and others are masked off. The count of active samples is given in the previous printout (3092). This selection remains active until it is replaced or deleted (there may not be more than one selection defined at a time per data base). This is what can be seen in the following display where we represent the `Elevation` only within the `inshore` selection.


```{r}
p = ggDefaultGeographic()
p = p + plot.grid(grid, name_raster="Elevation")
p = p + plot.decoration(title="My Grid", xlab="Easting", ylab="Northing")
ggPrint(p)
```

Note that any variable can be considered as a Selection: it must simply be assigned to the `sel` locator using the `setLocator` variable described earlier.

------------------------------------------------------------------------

# Final plot

On this final plot, we combine grid and point representations.

```{r}
p = ggDefaultGeographic()
p = p + plot.grid(grid, name_raster="Elevation")
p = p + plot.point(dat, name_size="Elevation", sizmin=1, sizmax=3, color="yellow")
p = p + plot.decoration(title="My Grid", xlab="Easting", ylab="Northing")
ggPrint(p)
```
