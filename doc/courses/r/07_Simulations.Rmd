---
title: "Gaussian simulations"
author: "gstlearn Team"
date: "February 2023"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r, include=FALSE}
## Global options for code chunks
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  cache=T,
  fig.width=5,fig.height=5,fig.align="center"
)
```




## Preamble

In this preamble, we load the **gstlearn** library and clean the workspace. 

```{r Loading libraries, message=FALSE,results=FALSE}
#--- MP --- 
rm(list=ls())
library(gstlearn)
library(ggplot2)
library(ggpubr)

## Global plot option
plot.setDefaultGeographic(dims=c(8,8))
```

We load two data bases:

* a data base `dat` containing point observations of two variables across Scotland: the elevation (`Elevation`) and the temperature (`January_temp`)
* a data base `target` containing a grid of points covering Scotland with a selection variable (`inshore`) selecting the points that are on land, and a variable (`Elevation`) giving the elevation at every point on land

```{r Preamble, message=FALSE}
## Observations
dlfile = "https://soft.minesparis.psl.eu/gstlearn/data/Scotland/Scotland_Temperatures.NF"
fileNF = "Scotland_Temperatures.NF"
download.file(dlfile, fileNF)
dat = Db_createFromNF(fileNF)

## Targets
dlfile = "https://soft.minesparis.psl.eu/gstlearn/data/Scotland/Scotland_Elevations.NF"
fileNF = "Scotland_Elevations.NF"
download.file(dlfile, fileNF)
target = DbGrid_createFromNF(fileNF)
```

We also compute an experimental variogram on the observations and fit a model on it.

```{r Fit model on obervations}
## Define and compute experimental variogram
varioparam = VarioParam_createOmniDirection(npas=40, dpas=10)
vario_raw2dir = Vario_create(varioparam, dat)
err = vario_raw2dir$compute()

## Fit model
fitmod = Model()
err = fitmod$fit(vario_raw2dir, 
                 types=ECov_fromKeys(c("NUGGET", "SPHERICAL", "CUBIC")))
fitmod$display()
```


```{r Global parameters, message=FALSE}
neighU = NeighUnique_create()

ndim = 2
defineDefaultSpace(ESpaceType_RN(), ndim)
```



---

## Unconditional simulation

To generate unconditional simulations, we use the `simtub` function. This function generates samples from a Gaussian random field with a covariance model defined in a `Model` object, using the turning bands algorithm. We specify

* the data base containing the target points on which we want to simulate the model (argument `dbout`)
* the `Model` object defining the model we want to simulate (argument `model`)
* the number of samples we want to generate (argument `nbsimu`)
* the number of turning bands (argument `nbtuba`)

Optionally, we can specify a seed number for the simulation (to ensure reproducibility). The `simtub` function adds the simulated samples directly to the target data base specified in `dbout` (with a naming convention that can be set through the argument `namconv`). Note that the samples generated by this function have the same mean as the one specified in the model object. If this mean has not specified been specified (through the `setMeans` method), then zero-mean simulations are generated.

Let us generate a sample from the model `fitmod` we fitted on the observations. First, we simulate the model with a single turning band.

```{r Unconditional Simulation with 1 band}
## Simulation
err = simtub(dbout=target, model=fitmod, 
             nbsimu=1,
             nbtuba=1, seed=12454,
             namconv=NamingConvention("Simu1"))
```

```{r Unconditional Simulation with 1 band - Plot}
## Plot
p = ggDefaultGeographic()
p = p + plot.grid(target, name_raster = "Simu1",
            show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p = p + plot.decoration(title="Simulation with 1 band")
ggPrint(p)
target$display()
```

Let us now simulate the model using 10 turning bands.

```{r Unconditional Simulation with 10 band}
## Simulation
err = simtub(dbout=target, model=fitmod, 
             nbsimu=1,
             nbtuba=10, seed=12454,
             namconv=NamingConvention("Simu10"))
```

```{r Unconditional Simulation with 10 band - Plot}
## Plot
p = ggDefaultGeographic()
p = p + plot.grid(target, name_raster = "Simu10",
            show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p = p + plot.decoration(title="Simulation with 1 band")
ggPrint(p)
```


Let us now simulate the model using 1000 turning bands.

```{r Unconditional Simulation with 1000 band}
## Simulation
err = simtub(dbout=target, model=fitmod, 
             nbsimu=1,
             nbtuba=1000, seed=12454,
             namconv=NamingConvention("Simu1000"))
```

```{r Unconditional Simulation with 1000 band - Plot}
## Plot
p = ggDefaultGeographic()
p = p + plot.grid(target, name_raster = "Simu1000",
            show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p = p + plot.decoration(title="Simulation with 1 band")
ggPrint(p)
```



---

## Conditional simulations

To perform conditional simulations, we use the same command as for unconditional simulations. We just need to supply two additional arguments: the data base containing the conditioning data (argument `dbin`), and the type of neighborhood used when conditioning the simulations (since this is done using kriging).

Circling back to our example, let us consider the temperature observations in the data base `dat` as conditioning points. Our aim is to generate simulations of the model `fitmod` that honor these data. 

We start by computing the mean of temperature observations and set it as the mean of the model, so that the future simulations of the model also share this mean.

```{r Perform_Conditional_Simulations}
## Compute mean temperature
mean_Temperature = dbStatisticsMono(dat, names=c("January_temp"), 
                                    opers=EStatOption_fromKeys(c("MEAN")))
cat(c("Mean of observed temperatures:", mean_Temperature))

## Add to model
err = fitmod$setMeans(mean_Temperature)
```

Then, to generate 10 conditional simulations using 1000 turning bands, we can simply run:

```{r}
## Parameters
nbsimu = 10
nbtuba = 1000
seed   = 13231

## Simulations
err = simtub(dbin=dat, dbout=target,
             model=fitmod, 
             neigh=neighU,
             nbsimu=nbsimu,
             nbtuba=nbtuba, seed=seed)
```

Let us display a few simulation results.

```{r One_Simulation_Outcome}
p1 = ggDefaultGeographic()
p1 = p1 + plot.grid(target, name_raster = "Simu*temp.1",
                    show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p1 = p1 + plot.point(dat,flagCst = T,pch=18,cex=0.5)
p2 = ggDefaultGeographic()
p2 = p2 + plot.grid(target, name_raster = "Simu*temp.2",
                    show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p2 = p2 + plot.point(dat,flagCst = T,pch=18,cex=0.5)
p3 = ggDefaultGeographic()
p3 = p3 + plot.grid(target, name_raster = "Simu*temp.3",
                    show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p3 = p3 + plot.point(dat,flagCst = T,pch=18,cex=0.5)
p4 = ggDefaultGeographic()
p4 = p4 + plot.grid(target, name_raster = "Simu*temp.4",
                    show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p4 = p4 + plot.point(dat,flagCst = T,pch=18,cex=0.5)
ggarrange(p1,p2,p3,p4,nrow=2,ncol=2)
```

Let us now compute the mean of the simulations we just generated. To do so, we use the `statistics` method of the `Db` class.

```{r Compute mean of simulations}
err = target$statistics(names=c("Simu.January_temp*"), 
                        opers=EStatOption_fromKeys(c("MEAN")),
                        flagStoreInDb=TRUE)

```


Let us compare the mean of the simulations with result from a simple kriging prediction of the temperature.

```{r Compute kriging}
## Compute kriging
err = kriging(dat, target, model=fitmod, 
              neigh = neighU,
              namconv=NamingConvention("KS"))

```

```{r Plot correlation plot}
## Plot correlation plot
p = ggplot()
p = p + plot.correlation(target, "Stats.MEAN", "KS*estim", flagDiag=TRUE, bins=100)
p = p + plot.decoration(xlab="Mean of Simulations", ylab="Simple Kriging Estimate",title = "Correlation plot - Mean of simulations / Kriging")
ggPrint(p)
```

---

## Simulations with External Drift

In this section, we show how to simulate a model with external drifts. To do so, it suffices to call the `simtub` function with a `Model` object that includes external drifts.

Let us build such a model, to illustrate our point. We start by reloading the two data bases of the Preambule.

```{r Reload data}
dlfile = "https://soft.minesparis.psl.eu/gstlearn/data/Scotland/Scotland_Temperatures.NF"
fileNF = "Scotland_Temperatures.NF"
download.file(dlfile, fileNF)
dat = Db_createFromNF(fileNF)

dlfile = "https://soft.minesparis.psl.eu/gstlearn/data/Scotland/Scotland_Elevations.NF"
fileNF = "Scotland_Elevations.NF"
download.file(dlfile, fileNF)
target = DbGrid_createFromNF(fileNF)
```

We will consider the temperature as our variable of interest, and the elevation as an external drift. Hence, we set the elevation variable to a `f` locator in both data bases.


```{r Set locators - ED}
## Set `f` locator to elevation in `dat` data base
err=dat$setLocator("Elevation", ELoc_F())

## Set `f` locator to elevation in `target` data base
err=target$setLocator("Elevation", ELoc_F())
```


Finally, we create a model with external drift, which we fit on our data.

```{r Fit model - ED}
## Create with external drift
model_ED = Model()
err = model_ED$setDriftIRF(order=0,nfex=1)

## Create experimental variogram of residuals
vario_resED = Vario_create(varioparam, dat)
err = vario_resED$compute(model=model_ED)

## Fit model on experimental variogram 
err = model_ED$fit(vario_resED, 
                   types=ECov_fromKeys(c("SPHERICAL","CUBIC")))
model_ED$display()
```
Let us plot the fitted model (solid line) together with the experimental variogram (dashed line).

```{r Plot fitted model - ED}
ggplot() + plot.varmod(vario_resED, model_ED)
```

Now, to generate 10 conditional simulations from the model with external drift that we just create, we call the `simtub` function with the same synthax as before.

```{r Simulations - ED}
## Simulation
err = simtub(dbin=dat, dbout=target, model=model_ED, 
             neigh=neighU,
             nbsimu=nbsimu,
             nbtuba=nbtuba, seed=seed)
```


Let us display a few simulation results.

```{r Plot simulations - ED}
p1 = ggDefaultGeographic()
p1 = p1 + plot.grid(target, name_raster = "Simu*temp.1",
                    show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p1 = p1 + plot.point(dat,flagCst = T,pch=18,cex=0.5)
p2 = ggDefaultGeographic()
p2 = p2 + plot.grid(target, name_raster = "Simu*temp.2",
                    show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p2 = p2 + plot.point(dat,flagCst = T,pch=18,cex=0.5)
p3 = ggDefaultGeographic()
p3 = p3 + plot.grid(target, name_raster = "Simu*temp.3",
                    show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p3 = p3 + plot.point(dat,flagCst = T,pch=18,cex=0.5)
p4 = ggDefaultGeographic()
p4 = p4 + plot.grid(target, name_raster = "Simu*temp.4",
                    show.legend.raster=TRUE,palette="Spectral",legend.name.raster="Value")
p4 = p4 + plot.point(dat,flagCst = T,pch=18,cex=0.5)
ggarrange(p1,p2,p3,p4,nrow=2,ncol=2)
```

Let us now compute the mean of the simulations we just generated, and compare it with a prediction by kriging with external drift.

```{r Compute mean of simulations and compare - ED}
err = target$statistics(names=c("Simu.January_temp*"), 
                        opers=EStatOption_fromKeys(c("MEAN")),
                        flagStoreInDb=TRUE)

## Compute kriging
err = kriging(dat, target, model=model_ED, 
              neigh = neighU,
              namconv=NamingConvention("KED"))

```

```{r Plot correlation plot - ED}
## Plot correlation plot
p = ggplot()
p = p + plot.correlation(target, "Stats.MEAN", "KED*estim", flagDiag=TRUE, bins=100)
p = p + plot.decoration(xlab="Mean of Simulations", ylab="Kriging with External Drift",title = "Correlation plot - Mean of simulations / Kriging with external drift")
ggPrint(p)
```

## Application : Probability of exceedence 

As an application, we show how to compute maps probabilities of exceeding a threshold. For instance, to compute the probabilities of being positive, we start by turning the simulation results into binary variables taking the value 1 if the simulated value is positive and 0 otherwise. Then, the probability of being positive is computed as the mean of these binary variables.

```{r Deriving probability to exceed Cutoff}
## Turn simulation results into binary variable
target["Simu.January_temp*"] = target["Simu.January_temp*"] > 0

## Average binary variables
err = target$statistics(names=c("Simu.January_temp*"), 
                        opers=EStatOption_fromKeys(c("MEAN")),
                        flagStoreInDb=TRUE,
                        namconv=NamingConvention("Proba"))
```

Let us plot the results.

```{r Plot probabilities}
p = ggDefaultGeographic()
p = p + plot.grid(target, "Proba.MEAN", show.legend.raster=TRUE, legend.name.raster="Probability")
p = p + plot.decoration(title="Probability for positive Temperatures")
ggPrint(p)
```
