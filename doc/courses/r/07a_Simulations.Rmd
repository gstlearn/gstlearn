---
title: "Gaussian simulations"
author: "gstlearn Team"
output:
  pdf_document:
    toc: true
  html_document:
    df_print: paged
    toc: true
editor_options: 
  chunk_output_type: console
---

<!-- SUMMARY: Simulations using Turning Bands method: derive the probability of exceeding a threshold. Extension when using an External Drift  -->

<!-- CATEGORY: Courses -->

```{r, include=FALSE}
## Global options for code chunks
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  cache=FALSE,
  fig.width=5,fig.height=5,fig.align="center"
)
```

## Preamble

In this preamble, we load the **gstlearn** library and clean the workspace. 

```{r Loading_libraries, message=FALSE,results=FALSE}
rm(list=ls())
library(gstlearn)
```

We load two data bases:

* a data base `dat` containing point observations of two variables across Scotland: the elevation (`Elevation`) and the temperature (`January_temp`)
* a data base `target` containing a grid of points covering Scotland with a selection variable (`inshore`) selecting the points that are on land, and a variable (`Elevation`) giving the elevation at every point on land

```{r Preamble, message=FALSE}
## Data points
fileNF = loadData("Scotland", "Scotland_Temperatures.NF")
dat = Db_createFromNF(fileNF)

## Target grid
fileNF = loadData("Scotland", "Scotland_Elevations.NF")
target = DbGrid_createFromNF(fileNF)
```

We also compute an experimental variogram on the observations and fit a model on it.

```{r Fit_model_on_obervations}
## Define and compute experimental variogram
varioparam = VarioParam_createOmniDirection(nlag=40, dlag=10)
vario_raw2dir = Vario_create(varioparam)
err = vario_raw2dir$compute(dat)

## Fit model
fitmod = Model()
err = fitmod$fit(vario_raw2dir, 
                 types=ECov_fromKeys(c("NUGGET", "SPHERICAL", "CUBIC")))
fitmod$display()
```


```{r Global_parameters, message=FALSE}
neighU = NeighUnique_create()

ndim = 2
defineDefaultSpace(ESpaceType_RN(), ndim)
```

---

## Unconditional simulation

To generate unconditional simulations, we use the `simtub` function. This function generates samples from a Gaussian random field with a covariance model defined in a `Model` object, using the turning bands algorithm. We specify

* the data base containing the target points on which we want to simulate the model (argument `dbout`)
* the `Model` object defining the model we want to simulate (argument `model`)
* the number of samples we want to generate (argument `nbsimu`)
* the number of turning bands (argument `nbtuba`)

Optionally, we can specify a seed number for the simulation (to ensure reproducibility). The `simtub` function adds the simulated samples directly to the target data base specified in `dbout` (with a naming convention that can be set through the argument `namconv`). Note that the samples generated by this function have the same mean as the one specified in the model object. If this mean has not specified been specified (through the `setMeans` method), then zero-mean simulations are generated.

Let us generate a sample from the model `fitmod` we fitted on the observations. First, we simulate the model with a single turning band.

```{r Unconditional Simulation with 1 band}
err = simtub(dbout=target, model=fitmod, 
             nbsimu=1,
             nbtuba=1, seed=12454,
             namconv=NamingConvention("Simu1"))
target$display()
```

```{r Unconditional Simulation with 1 band - Plot}
p = plot.init(asp=1)
p = p + plot.raster(target, name = "Simu1",
            flagLegend=TRUE,palette="Spectral",
            legendName="Value")
p = p + plot.decoration(title="Simulation with 1 band")
plot.end(p)
```

Let us now simulate the model using 10 turning bands.

```{r Unconditional Simulation with 10 band}
err = simtub(dbout=target, model=fitmod, 
             nbsimu=1,
             nbtuba=10, seed=12454,
             namconv=NamingConvention("Simu10"))
```

```{r Unconditional Simulation with 10 band - Plot}
p = plot.init(asp=1)
p = p + plot.raster(target, name = "Simu10",
            flagLegend=TRUE,palette="Spectral",legendName="Value")
p = p + plot.decoration(title="Simulation with 1 band")
plot.end(p)
```

Let us now simulate the model using 1000 turning bands.

```{r Unconditional Simulation with 1000 band}
err = simtub(dbout=target, model=fitmod, 
             nbsimu=1,
             nbtuba=1000, seed=12454,
             namconv=NamingConvention("Simu1000"))
```

```{r Unconditional Simulation with 1000 band - Plot}
p = plot.init(asp=1)
p = p + plot.raster(target, name = "Simu1000",
            flagLegend=TRUE,palette="Spectral",legendName="Value")
p = p + plot.decoration(title="Simulation with 1 band")
plot.end(p)
```

---

## Conditional simulations

To perform conditional simulations, we use the same command as for unconditional simulations. We just need to supply two additional arguments: the data base containing the conditioning data (argument `dbin`), and the type of neighborhood used when conditioning the simulations (since this is done using kriging).

Circling back to our example, let us consider the temperature observations in the data base `dat` as conditioning points. Our aim is to generate simulations of the model `fitmod` that honor these data. 

We first must control that our data follow more or less a gaussian distribution.

```{r}
p = plot.init(dims = c(8, 8))
p = p + plot.hist(dat,name="January_temp", bins=10)
plot.end(p)
```

Then, we compute the mean of temperature observations and set it as the mean of the model, so that the future simulations of the model also share this mean.

```{r Perform_Conditional_Simulations}
## Compute mean temperature
mean_Temperature = dbStatisticsMono(dat, names=c("January_temp"),
                         opers=EStatOption_fromKeys(c("MEAN")))$getValue(0,0)
cat(paste("Mean of observed temperatures:", round(mean_Temperature,3)))

## Add to model
err = fitmod$setMeans(mean_Temperature)
```

Then, to generate 10 conditional simulations using 1000 turning bands, we can simply run:

```{r}
## Parameters
nbsimu = 10
nbtuba = 1000
seed   = 13231

## Simulations
err = simtub(dbin=dat, dbout=target,
             model=fitmod, 
             neigh=neighU,
             nbsimu=nbsimu,
             nbtuba=nbtuba, seed=seed)
```

Let us display a few simulation results.

```{r One_Simulation_Outcome}
p1 = plot.init(asp=1)
p1 = p1 + plot.raster(target, name = "Simu*temp.1",
                    flagLegend=TRUE,palette="Spectral",legendName="Value")
p1 = p1 + plot.symbol(dat,flagCst = T,pch=18,cex=0.5)
p2 = plot.init(asp=1)
p2 = p2 + plot.raster(target, name = "Simu*temp.2",
                    flagLegend=TRUE,palette="Spectral",legendName="Value")
p2 = p2 + plot.symbol(dat,flagCst = T,pch=18,cex=0.5)
p3 = plot.init(asp=1)
p3 = p3 + plot.raster(target, name = "Simu*temp.3",
                    flagLegend=TRUE,palette="Spectral",legendName="Value")
p3 = p3 + plot.symbol(dat,flagCst = T,pch=18,cex=0.5)
p4 = plot.init(asp=1)
p4 = p4 + plot.raster(target, name = "Simu*temp.4",
                    flagLegend=TRUE,palette="Spectral",legendName="Value")
p4 = p4 + plot.symbol(dat,flagCst = T,pch=18,cex=0.5)
ggarrange(p1,p2,p3,p4,nrow=2,ncol=2)
```

Let us now compute the mean of the simulations we just generated. To do so, we use the `statistics` method of the `Db` class.

```{r Compute_mean_of_simulations}
target$statisticsBySample(names=c("Simu.January_temp*"), 
                        opers=EStatOption_fromKeys(c("MEAN")))
```

Let us compare the mean of the simulations with result from a simple kriging prediction of the temperature.

```{r Compute_kriging}
err = kriging(dat, target, model=fitmod, 
              neigh = neighU,
              namconv=NamingConvention("KS"))
```

```{r Plot_correlation_plot}
## Plot correlation plot
p = plot.init(c(8, 8))
p = p + plot.correlation(target, "Stats.MEAN", "KS*estim", flagDiag=TRUE, bins=100)
p = p + plot.decoration(xlab="Mean of Simulations", 
                        ylab="Simple Kriging Estimate",
                        title = "Correlation plot")
plot.end(p)
```

---

## Simulations with External Drift

In this section, we show how to simulate a model with external drifts. To do so, it suffices to call the `simtub` function with a `Model` object that includes external drifts.

Let us build such a model, to illustrate our point. We start by reloading the two data bases of the Preambule.

```{r Reload_data}
## Data points
fileNF = loadData("Scotland", "Scotland_Temperatures.NF")
dat = Db_createFromNF(fileNF)

## Target grid
fileNF = loadData("Scotland", "Scotland_Elevations.NF")
target = DbGrid_createFromNF(fileNF)
```

We will consider the temperature as our variable of interest, and the elevation as an external drift. Hence, we set the elevation variable to a `f` locator in both data bases.

```{r Set_locators-ED}
## Set `f` locator to elevation in `dat` data base
err=dat$setLocator("Elevation", ELoc_F())

## Set `f` locator to elevation in `target` data base
err=target$setLocator("Elevation", ELoc_F())
```

Finally, we create a model with external drift, which we fit on our data.

```{r Fit_model-ED}
## Create with external drift
model_ED = Model()
err = model_ED$setDriftIRF(order=0,nfex=1)

## Create experimental variogram of residuals
vario_resED = Vario_create(varioparam)
err = vario_resED$compute(dat,model=model_ED)

## Fit model on experimental variogram 
err = model_ED$fit(vario_resED, 
                   types=ECov_fromKeys(c("SPHERICAL","CUBIC")))
model_ED$display()
```

Let us plot the fitted model (solid line) together with the experimental variogram (dashed line).

```{r Plot_fitted_model-ED}
plot.init(c(8, 8)) + plot.varmod(vario_resED, model_ED)
```

Now, to generate 10 conditional simulations from the model with external drift that we just create, we call the `simtub` function with the same synthax as before.

```{r Simulations-ED}
err = simtub(dbin=dat, dbout=target, model=model_ED, 
             neigh=neighU,
             nbsimu=nbsimu,
             nbtuba=nbtuba, seed=seed)
```

Let us display a few simulation results.

```{r Plotsimulations-ED}
p1 = plot.init(asp=1)
p1 = p1 + plot.raster(target, name = "Simu*temp.1",
                    flagLegend=TRUE,palette="Spectral",legendName="Value")
p1 = p1 + plot.symbol(dat,flagCst = T,pch=18,cex=0.5)
p2 = plot.init(asp=1)
p2 = p2 + plot.raster(target, name = "Simu*temp.2",
                    flagLegend=TRUE,palette="Spectral",legendName="Value")
p2 = p2 + plot.symbol(dat,flagCst = T,pch=18,cex=0.5)
p3 = plot.init(asp=1)
p3 = p3 + plot.raster(target, name = "Simu*temp.3",
                    flagLegend=TRUE,palette="Spectral",legendName="Value")
p3 = p3 + plot.symbol(dat,flagCst = T,pch=18,cex=0.5)
p4 = plot.init(asp=1)
p4 = p4 + plot.raster(target, name = "Simu*temp.4",
                    flagLegend=TRUE,palette="Spectral",legendName="Value")
p4 = p4 + plot.symbol(dat,flagCst = T,pch=18,cex=0.5)
ggarrange(p1,p2,p3,p4,nrow=2,ncol=2)
```

Let us now compute the mean of the simulations we just generated, and compare it with a prediction by kriging with external drift.

```{r Compute_mean_of_simulations_and_compare-ED}
target$statisticsBySample(names=c("Simu.January_temp*"), 
                        opers=EStatOption_fromKeys(c("MEAN")))

## Compute kriging
err = kriging(dat, target, model=model_ED, 
              neigh = neighU,
              namconv=NamingConvention("KED"))
```

```{r Plot_correlation_plot-ED}
p = plot.init(c(8,8))
p = p + plot.correlation(target, "Stats.MEAN", "KED*estim", flagDiag=TRUE, bins=100)
p = p + plot.decoration(xlab="Mean of Simulations", ylab="Kriging with External Drift",title = "Correlation plot")
plot.end(p)
```

## Application : Probability of exceedence 

As an application, we show how to compute maps probabilities of exceeding a threshold. For instance, to compute the probabilities of being positive, we start by turning the simulation results into binary variables taking the value 1 if the simulated value is positive and 0 otherwise. Then, the probability of being positive is computed as the mean of these binary variables.

```{r Deriving_probability_to_exceed_Cutoff}
## Turn simulation results into binary variable
target["Simu.January_temp*"] = target["Simu.January_temp*"] > 0

## Average binary variables
target$statisticsBySample(names=c("Simu.January_temp*"), 
                        opers=EStatOption_fromKeys(c("MEAN")),
                        namconv=NamingConvention("Proba"))
```

Let us plot the results.

```{r Plot_probabilities}
p = plot.init(asp=1)
p = p + plot.raster(target, "Proba.MEAN", flagLegend=TRUE, legendName="Probability")
p = p + plot.decoration(title="Probability for positive Temperatures")
plot.end(p)
```
