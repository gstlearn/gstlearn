---
title: "Tutorial 2D"
author: "D. Renard"
date: "25 juin 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
library(gstlearn)
```

Global variables

```{r}
verbose = TRUE
graphics = TRUE
OptCst_define(ECst_NTCOL(),6)
```

# Reading data

The data are stored in a CSV format in the file called Pollution.dat

**
At this stage:
- it is not possible to pass the list of variable names *c("X","Y")*.
- to pass the FLAGS for *DbStringFormat* (they are not an ENUM)
**

```{r}
dataDir = "../../data/Pollution"
filepath = paste(dataDir,"Pollution.dat",sep="/")

mydb = Db_createFromCSV(filepath,CSVformat())
err = mydb$setLocator("X",ELoc_X(),0)
err = mydb$setLocator("Y",ELoc_X(),1)
err = mydb$setLocator("Zn",ELoc_Z())
if (verbose)
{
  dbfmt = DbStringFormat()
#  dbfmt$setParams(FLAG_RESUME | FLAG_EXTEND | FLAG_VARS) 
  mydb$display(dbfmt)
}
```

Accessing to the variable names

```{r}
cat("List of all variable names =",mydb$getAllNames())
```

Extracting the vector containing the Zn variable in order to perform a selection

```{r}
tabZn = mydb$getColumn("Zn")
selZn = as.numeric(tabZn < 20)
mydb$addSelection(selZn,"sel")
mydb$setLocator('Pb',ELoc_Z())
if (verbose)
    mydb$display()
```

Display my Data (with samples represented by color and size)

```{r}
if (graphics)
    plot.point(mydb,color_name="Pb",title="Data Set")
```

# Variograms

We first define the geometry of the variogram calculations

```{r}
myVarioParamOmni = VarioParam()
mydir = DirParam(2,10,1.)
myVarioParamOmni$addDir(mydir)
```

We use the variogram definition in order to calculate the variogram cloud.

```{r}
dbcloud = db_variogram_cloud(mydb, myVarioParamOmni)
```

We recall that the Variogram cloud is calculated by filling an underlying grid where each cell is painted according to the number of pairs at the given distance and given variability. Representing the variogram cloud.

```{r}
if (graphics)
    plot.grid(dbcloud,"Cloud*",title="Variogram Cloud")
```

Calculating the experimental omni-directional variogram

```{r}
myVarioOmni = Vario(myVarioParamOmni,mydb)
err = myVarioOmni$compute(ECalcVario_VARIOGRAM())
if (verbose)
    myVarioOmni$display()
```

The variogram is represented graphically for a quick check

```{r}
if (graphics)
    plot.varmod(myVarioOmni,
                title="Omni-directional Variogram for Pb")
```

Calculate a variogram in several directions

```{r}
myvarioParam = VarioParam()
mydirs = DirParam_createMultiple(2, 4, dpas=1., npas=10)
myvarioParam$addMultiDirs(mydirs)
myvario = Vario(myvarioParam,mydb)
myvario$compute(ECalcVario_VARIOGRAM())
if (verbose)
    myvario$display()
```

```{r}
if (graphics)
    plot.varmod(myvario,title="Multi-Directional Variogram of Pb")
```

Calculating the Variogram Map

```{r}
myvmap = db_vmap_compute(mydb,ECalcVario_VARIOGRAM(),c(20,20))
if (verbose)
    myvmap$display()
```

```{r}
if (graphics)
    plot.grid(myvmap,"*Var",title="Variogram Map")
```

# Model

Fitting a Model. We call the Automatic Fitting procedure providing the list of covariance functions to be tested.

```{r}
vcovs = VectorEnumCovs()
vcovs$push_back(ECov_EXPONENTIAL)
vcovs$push_back(ECov_SPHERICAL)
mymodel = Model_createFromDb(mydb)
err = mymodel$fit(myvario,vcovs)
```

Visualizing the resulting model, overlaid on the experimental variogram

```{r}
if (graphics)
    plot.varmod(myvario,mymodel,title="Model for Pb")
```

## Model with equality constraints

We can impose some constraints on the parameters during the fit. For instance here, we impose an equality constraint on the range (range = 1).

```{r}
myModelConstrained = Model_createFromDb(mydb)
constr = Constraints()
paramid = CovParamId(0,0,EConsElem_RANGE(),0,0)
constr$addItem(ConsItem(paramid,EConsType_EQUAL(),1.))
opt = Option_AutoFit()
err = myModelConstrained$fit(myVarioOmni,vcovs,FALSE,opt,constr)
myModelConstrained
```

We can impose inequality constraints by using EConsType.LOWER or EConsType.UPPER.

## Adding a drift

```{r}
mymodel$addDrift(Drift1(mymodel$getContext()))
if (verbose)
    mymodel$display()
```

This paragraph has been added (unless fitting is corrected)

```{r}
mymodel$addCovFromParam(ECov_EXPONENTIAL(),sill=2,range=1.2)
```

# Defining the Neighborhood

We initiate a Neigborhood (Moving with a small number of samples for Demonstration)

```{r}
myneigh = NeighMoving_create(ndim=2,flag_xvalid=FALSE,nmaxi=6,radius=10)
if (verbose)
    myneigh$display()
```

## Checking the Moving Neighborhood

We must first create a Grid which covers the area of interest

```{r}
mygrid = DbGrid_createCoveringDb(mydb,c(80,72),c(0.5,0.5),c(107.,481.),c(2,2))
if (verbose)
    mygrid$display()
```

We can now test the neighborhood characteristics for each node of the previously defined grid.

```{r}
err = test_neigh(mydb,mygrid,mymodel,myneigh)
if (verbose)
    mygrid$display()
```

We can visualize some of the newly created variables, such as:

- the number of points per neighborhood

```{r}
if (graphics)
    plot.grid(mygrid,"Neigh*Number",
              title="Number of Samples per Neighborhood")
```

- the one giving the maximum distance per neighborhood

```{r}
if (graphics)
    plot.grid(mygrid,"Neigh*MaxDist",
              title="Maximum Distance per Neighborhood")
```

# Cross-validation

We can now process the cross-validation step

```{r}
err = xvalid(mydb,mymodel,myneigh)
if (verbose)
    mydb$display()
```

```{r}
if (graphics)
    plot.hist(mydb,"Xvalid.Pb.stderr")
```

# Estimating by Kriging

We now perform the Estimation by Ordinary Kriging. 
The Neighborhood is changed into a Unique Neighborhood.

```{r}
mydb$setLocator("Pb",ELoc_Z())
myneigh = NeighUnique_create(2)
err = kriging(mydb,mygrid,mymodel,myneigh)
if (verbose)
    mygrid$display()
```

Visualizing the results

```{r}
if (graphics)
    ax = plot.grid(mygrid,"Kriging.Pb.estim")
    plot.point(mydb,"Pb",title="Estimate of Pb",ax=ax)
```

```{r}
if (graphics)
    ax = plot.grid(mygrid,"Kriging.Pb.stdev")
    plot.point(mydb,"Pb",title="St. Deviation of Pb",ax=ax)
```

# Simulations

We must first transform the Data into Gaussian

```{r}
myanamPb = AnamHermite(30)
myanamPb$fit(mydb)
if (verbose)
    myanamPb$display()
```

We can produce the Gaussian Anamorphosis graphically within its definition domain.

```{r, eval=FALSE}
if (graphics)
    ax = plot.anam(myanamPb)
```

The next step consists in translating the target variable ('Pb') into its Gaussian transform

