---
title: "Gauss Integration"
author: "D. Renard, N. Desassis, X. Freulon"
date: "May 17th 2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

Load the gstlearn package under R.

```{r}
library(gstlearn)
```

```{r}
OptCst_defineByKey("ASP",0)
```

# General Introduction

The objective of this document is to provide some guides for manipulation of Hermite polynomials.
In particular, it will give some hints for calculating of complex expressions (e.g. metal above cutoff) and be double checked using a Monte Carlo approach.

It will also demonstrate the quality of the polynomial expansion for a given known distribution of the data (i.e. lognormal).
Finally it will serve in demonstrating the ability of representing any function through a Hermite polynomial expansion.

# Part I

The objective of the first part is to compute

$$
\psi_1(\alpha,\beta)=\int \phi(\alpha + \beta \, u) \, g(u) \, du
$$

and

$$
\psi_2(\alpha,\beta) = \int \phi^2(\alpha + \beta \, u) \, g(u) \, du
$$

for a function $\phi$ in order to compute the conditional expectation and the conditional variance, usually defined by its expansion in terms of Hermite polynomials:

$$
\phi(y) = \sum_{n=0}^{N} a_n \eta_n(y)
$$

In particular, we may be interested in the case where $\alpha=r y$ and $\beta = \sqrt { { 1-r^2 } }$. Note that $|\beta|< 1$.

Many methods can be used to compute these draw.matrix:

* the Monte-Carlo integration (easy)

* the computation of the Hermite coefficient for $\phi$ and $\phi^2$ 

$$
\int_{-\infty}^{+\infty} \eta_n(\alpha + \beta \, u)\, g(u) \, du = (1-\beta^2)^n \, \eta_n(\frac{\alpha}{\sqrt{1-\beta^2}})
$$

# Evaluation on the lognormal case

Processing parameters

```{r Initial setup, echo=TRUE, eval=TRUE}
nbpoly = 100
nbsimu = 1000
params = list(nbpoly=nbpoly, nbsimu=nbsimu, yc=1.5)
```

We consider the Lognormal case (where the anamorphosis is known exactly).

```{r lognormal, echo=TRUE, eval=TRUE}
m     <- 2.5
sigma <- 0.5
hn     = hermiteLognormal(m, sigma, params$nbpoly)
```

We calculate the various functions (expectation, ore and metal quantity, for expectation and standard deviation) for different values of $y$ varying from -3 to 3 and different values of $r$ varying from 0 to 1. The results are stored in a Db (organized as a matrix) whose parameters are given next.

```{r Grid Definition}
y0  = -3
dy  = 0.1
dr  = 0.1
y   = seq(-3,3,by=dy)
ny  = length(y)
r   = seq(1,0,by=-dr)
nr  = length(r)
```

# Comparisons

We evaluate the variable, the ore and metal quantity above a cutoff, in conditional expectation or in conditional standard deviation.

```{r Internal Functions, echo = FALSE}
# Function to generate the title
get.title <- function(type,calcul,flag.est,params)
{
  if (calcul == 1)
  {
    if (flag.est)
      title = "E(Z)"
    else
      title = "St.dev.(Z)"
  }
  else if (calcul == 2)
  {
    if (flag.est)
      title = paste("Ore above Cutoff (",params$yc,")")
    else
      title = paste("Ore St.Dev. above Cutoff (",params$yc,")")
  }
  else
  {
    if (flag.est)
      title = paste("Metal above Cutoff (",params$yc,")")
    else
      title = paste("Metal St.Dev. above Cutoff (",params$yc,")")
  }
  
  if (type == 1)
    title = paste(title," using Hermite (",params$nbpoly,")")
  else if (type == 2)
    title = paste(title," using Monte Carlo (",params$nbsimu,")")

  title
}

# Function to calculate a quantity (Cond. Exp., Tonnage, Metal) by Hermite or Monte Carlo
# for different parameters of the parameters
# The results are provided on a regular Db
calculate.matrix <- function(type,calcul,flag.est,params)
{
  # Setting the result grid
  
  db = DbGrid_create(nx=c(ny,nr),x0=c(y0,0),dx=c(dy,dr))
  
  if (type == 1)
  {
    # Calculation using Hermite expansion
    
    if (calcul == 1)
    {
      if (flag.est)
        psi = hermiteCondExp(db["x1"],db["x2"],hn)
      else
        psi = hermiteCondStd(db["x1"],db["x2"],hn)
    }
    else if (calcul == 2)
    {
      if (flag.est)
        psi = hermiteIndicator(params$yc,db["x1"],db["x2"])
      else
        psi = hermiteIndicatorStd(params$yc,db["x1"],db["x2"])
    }
    else if (calcul == 3)
    {
      if (flag.est)
        psi = hermiteMetal(params$yc,db["x1"],db["x2"],hn)
      else
        psi = hermiteMetalStd(params$yc,db["x1"],db["x2"],hn)
    }
    else
      stop("Wrong value for 'calcul'")
  }
  else if (type == 2)
  {
    # Calculation using Monte Carlo
    
    if (calcul == 1)
    {
      if (flag.est)
        psi = MCCondExp(db["x1"],db["x2"],hn,params$nbsimu)
      else
        psi = MCCondStd(db["x1"],db["x2"],hn,params$nbsimu)
    }
    else if (calcul == 2)
    {
      if (flag.est)
        psi = MCIndicator(params$yc,db["x1"],db["x2"],params$nbsimu)
      else
        psi = MCIndicatorStd(params$yc,db["x1"],db["x2"],params$nbsimu)
    }
    else if (calcul == 3)
    {
      if (flag.est)
        psi = MCMetal(params$yc,db["x1"],db["x2"],hn,params$nbsimu)
      else
        psi = MCMetalStd(params$yc,db["x1"],db["x2"],hn,params$nbsimu)
    }
    else
      stop("Wrong value for 'calcul'")
  }
  else
    stop("Wrong value for 'type'")
  
  uid = db$addColumns(as.numeric(psi),"psi")
  db
}

# Representation of the grid
draw.matrix <- function(type,calcul,flag.est,params,flag.cut=TRUE)
{
  title = get.title(type,calcul,flag.est,params)
  db = calculate.matrix(type,calcul,flag.est,params)
  p = plot.grid(db,name="psi",title=title)
  if (flag.cut) p <- p + geom_vline(xintercept = params$yc)
  p
}

# Representation of a scatter plot
draw.correlation <- function(calcul,flag.est,params,flag.iso=TRUE)
{
  title = get.title(0,calcul,flag.est,params)
  db1 = calculate.matrix(type=1,calcul,flag.est,params)
  db2 = calculate.matrix(type=2,calcul,flag.est,params)
  plot.correlation(db1,"psi","psi",db2,title=title, diagLine=TRUE,
                    xlab="Hermite",ylab="Monte Carlo")
}
```

Calculating all elements using either Hermite expansion or Monte Carlo Simulations

```{r Grids for Estimation and Variances}
draw.matrix(type=1,calcul=1,flag.est=TRUE,params,flag.cut=FALSE)
draw.matrix(type=2,calcul=1,flag.est=TRUE,params,flag.cut=FALSE)
draw.correlation(calcul=1,flag.est=TRUE,params)

draw.matrix(type=1,calcul=2,flag.est=TRUE,params)
draw.matrix(type=2,calcul=2,flag.est=TRUE,params)
draw.correlation(calcul=2,flag.est=TRUE,params)

draw.matrix(type=1,calcul=3,flag.est=TRUE,params)
draw.matrix(type=2,calcul=3,flag.est=TRUE,params)
draw.correlation(calcul=3,flag.est=TRUE,params)

draw.matrix(type=1,calcul=1,flag.est=FALSE,params,flag.cut=FALSE)
draw.matrix(type=2,calcul=1,flag.est=FALSE,params,flag.cut=FALSE)
draw.correlation(calcul=1,flag.est=FALSE,params)

draw.matrix(type=1,calcul=2,flag.est=FALSE,params)
draw.matrix(type=2,calcul=2,flag.est=FALSE,params)
draw.correlation(calcul=2,flag.est=FALSE,params)

draw.matrix(type=1,calcul=3,flag.est=FALSE,params)
draw.matrix(type=2,calcul=3,flag.est=FALSE,params)
draw.correlation(calcul=3,flag.est=FALSE,params)
```

