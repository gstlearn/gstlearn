---
title: "Tutorial Graphics"
author: "D. Renard"
date: "5 february 2023"
output:
  pdf_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
library(gstlearn)
library(ggplot2)
library(ggpubr)
```

This chapter gives some demonstration on the various possibilities offered by the Polygon class.
Remember that the Polygon is an item which is specifically defined in 2-D space. However an extension to 3-D space has been programmed: the polyhedron is regarded as a 3-D object with a polygonal trace in the 2-D plane and a limite extension along the third direction. 

In this tutorial, we concentrate on the 2-D case.

```{r}
defineDefaultSpace(ESpaceType_RN(), 2)
```

To visualize the impact of the polygons, it is usual to check its impact on a Db (a Grid one makes the demonstration more efficient).
Moreover it makes sense to generate a variable which presents some spatial continuity on this grid, such as a variable created by simulation.

```{r}
mygrid = DbGrid_create(nx=c(150,100),dx=c(1,1))
mymodel = Model_createFromParam(ECov_CUBIC(), range=30, sill=1)
err = simtub(NULL,mygrid,mymodel)
```

The variable (called *Simu*) defined on the grid is visualized first.

```{r}
ggplot() + plot.grid(mygrid, palette="inferno")
```

We now define the items of the PolyGon class.
Let us recall that a polygon is a set of Polysets. Each polyset is defined by a series of 2-D points which serve as vertices. The polyset can be closed or not (it will be closed automatically if necessary, depending on its usage).
The Polygon (in broad sense) can be used essentially;
- for visualization purpose
- to apply a selection on the elements of a Db: we will apply it on the nodes of our grid for demonstration sake.

Let us start by a simple polygon constituted of a single polyset.

```{r}
polygon = Polygons()
polyset1 = PolySet(x=c(40, 75, 100, 15), y = c(25, 10, 75, 60))
polygon$addPolySet(polyset1)
```

Displaying the contents of the polygon:

- sort output

```{r}
polygon$display()
```

- more lengthy printout

```{r}
polygon$display(AStringFormat(level=2))
```

Some nice features are available such as:

```{r}
polygon$getSurface()
```

We can now overlay the polygon (filled in "yellow") on top of the grid

```{r}
p = ggplot()
p = p + plot.grid(mygrid, palette="inferno")
p = p + plot.polygon(polygon, fill="yellow")
ggPrint(p)
```

More interesting is to use this polygon in order to create a selection on the grid nodes. Then the only nodes lying within the polygon will be considered as active.

```{r}
db_polygon(mygrid, polygon)
mygrid
```

Displaying the grid (taking the selection into account) is performed now. Note that the polygon is overlaid again but in a transparent mode

```{r}
p = ggplot()
p = p + plot.grid(mygrid, palette="inferno")
p = p + plot.polygon(polygon, fill=NA, color="yellow", linewidth=2)
ggPrint(p)
```

Let us make the polygon more complex by adding other polysets which partly overlay each one another.

```{r}
polyset2 = PolySet(x=c(50, 100, 100, 50), y=c(30, 30, 55, 55))
polygon$addPolySet(polyset2)
polyset3 = PolySet(x=c(25, 100, 55), y=c(25,25, 80))
polygon$addPolySet(polyset3)
polygon$display(AStringFormat(level=2))
```

In the following figure, we display the edges of the different polysets

```{r}
ggplot() + plot.polygon(polygon, fill=NA)
```

Obviously, the three polysets of the polygon overlay. So the impact of using this polygon for selection will be interesting.

In this first example, the selection algorithm is quite simple:
*a grid node is considered as active as soon as it belongs to one of the polysets*

```{r}
db_polygon(mygrid, polygon)
ggplot() + plot.grid(mygrid, palette="inferno")
```

In the second example:
* a grid node is considered as active if the number of polysets to which it belongs is odd*.
This feature enables a polygon to contain **holes** as demonstrated in the next example

```{r}
db_polygon(mygrid, polygon, flag_nested=TRUE)
ggplot() + plot.grid(mygrid, palette="inferno")
```
